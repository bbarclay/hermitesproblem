{
    "cells": [
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "# A Complete Solution to Hermite's Problem for Cubic Irrationals\n",
       "\n",
       "## Introduction\n",
       "\n",
       "Hermite's problem (1848): Find a generalization of continued fractions that characterizes cubic irrationals through periodicity.\n",
       "\n",
       "**Background:**\n",
       "- Continued fractions: periodic $\\iff$ quadratic irrational\n",
       "- Previous attempts (Jacobi-Perron, Brun, et al.): failed for complex conjugate roots\n",
       "\n",
       "**Our Solution:**\n",
       "1. **HAPD Algorithm:** Projective space transformation yielding periodicity iff input is cubic irrational\n",
       "2. **Matrix Approach:** Companion matrix characterization via trace sequences\n",
       "3. **Modified Sin²-Algorithm:** Extension handling complex conjugate roots"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Setup and Configuration\n",
       "\n",
       "Importing required libraries and initializing the solvers with precision parameters."
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "import math\n",
       "import numpy as np\n",
       "import matplotlib.pyplot as plt\n",
       "import sympy as sp\n",
       "from mpmath import mp\n",
       "from IPython.display import display, Math, Markdown\n",
       "\n",
       "# Configure plotting\n",
       "plt.style.use('seaborn-whitegrid')\n",
       "plt.rcParams['figure.figsize'] = (10, 6)\n",
       "plt.rcParams['axes.labelsize'] = 14\n",
       "plt.rcParams['axes.titlesize'] = 16\n",
       "\n",
       "# Set high precision for mpmath calculations (required for periodicity detection)\n",
       "mp.dps = 100\n",
       "\n",
       "# Import hermite_solver package - exception handling for various environments\n",
       "try:\n",
       "    from hermite_solver import HermiteSolver, HAPD, MatrixApproach, ComputationalMethods, Utils\n",
       "    solver_import_successful = True\n",
       "except ImportError as e:\n",
       "    solver_import_successful = False\n",
       "    print(f\"Import Error: {e}\")\n",
       "    print(\"Attempting fallback imports...\")\n",
       "    try:\n",
       "        # Fallback for direct imports if in the project root\n",
       "        import sys\n",
       "        import os\n",
       "        sys.path.insert(0, os.path.abspath('../')) \n",
       "        from hermite_solver import HermiteSolver, HAPD, MatrixApproach, ComputationalMethods, Utils\n",
       "        solver_import_successful = True\n",
       "    except ImportError as e2:\n",
       "        print(f\"Fallback import failed: {e2}\")\n",
       "        print(\"Define minimal implementations for demonstration purposes...\")\n",
       "        # Define minimal implementations for demo if imports fail\n",
       "        class MinimalUtils:\n",
       "            @staticmethod\n",
       "            def find_minimal_polynomial(alpha, max_degree=3):\n",
       "                # Simplified implementation\n",
       "                if abs(alpha - mp.cbrt(2)) < 1e-10:\n",
       "                    return [1, 0, 0, -2]  # x^3 - 2\n",
       "                if abs(alpha - mp.cbrt(3)) < 1e-10:\n",
       "                    return [1, 0, 0, -3]  # x^3 - 3\n",
       "                return None\n",
       "                \n",
       "            @staticmethod\n",
       "            def find_real_root(poly):\n",
       "                # Find a real root of the polynomial with coefficients poly\n",
       "                x = sp.symbols('x')\n",
       "                expr = sum(c*x**(len(poly)-1-i) for i, c in enumerate(poly))\n",
       "                roots = sp.solve(expr, x)\n",
       "                real_roots = [complex(r).real for r in roots if abs(complex(r).imag) < 1e-10]\n",
       "                return float(real_roots[0]) if real_roots else None\n",
       "                \n",
       "            @staticmethod\n",
       "            def continued_fraction(alpha, max_terms=20, tolerance=1e-15):\n",
       "                # Compute continued fraction\n",
       "                cf = []\n",
       "                for _ in range(max_terms):\n",
       "                    a = int(mp.floor(alpha))\n",
       "                    cf.append(a)\n",
       "                    frac = alpha - a\n",
       "                    if abs(frac) < tolerance:\n",
       "                        break\n",
       "                    alpha = 1 / frac\n",
       "                return cf\n",
       "        \n",
       "        Utils = MinimalUtils()\n",
       "\n",
       "# Instantiate the solvers if import was successful\n",
       "if solver_import_successful:\n",
       "    # Set a higher tolerance for numerical stability\n",
       "    solver = HermiteSolver(max_iterations=1000, tolerance=1e-15)\n",
       "    hapd_algo = solver.hapd\n",
       "    matrix_algo = solver.matrix\n",
       "    comp_methods = solver.computational\n",
       "    print(\"HermiteSolver instantiated successfully.\")\n",
       "    print(f\"mpmath precision: {mp.dps} digits\")\n",
       "else:\n",
       "    print(\"WARNING: Using minimal implementations for demonstration only.\")\n",
       "\n",
       "# Utility function for LaTeX display\n",
       "def display_math(expr):\n",
       "    display(Math(expr))\n",
       "    \n",
       "# Utility function for polynomial display\n",
       "def format_polynomial(coeffs):\n",
       "    if not coeffs:\n",
       "        return \"0\"\n",
       "    terms = []\n",
       "    degree = len(coeffs) - 1\n",
       "    for i, coef in enumerate(coeffs):\n",
       "        if coef == 0:\n",
       "            continue\n",
       "        power = degree - i\n",
       "        if power == 0:\n",
       "            terms.append(f\"{coef:g}\")\n",
       "        elif power == 1:\n",
       "            if coef == 1:\n",
       "                terms.append(\"x\")\n",
       "            elif coef == -1:\n",
       "                terms.append(\"-x\")\n",
       "            else:\n",
       "                terms.append(f\"{coef:g}x\")\n",
       "        else:\n",
       "            if coef == 1:\n",
       "                terms.append(f\"x^{power}\")\n",
       "            elif coef == -1:\n",
       "                terms.append(f\"-x^{power}\")\n",
       "            else:\n",
       "                terms.append(f\"{coef:g}x^{power}\")\n",
       "    if not terms:\n",
       "        return \"0\"\n",
       "    poly_str = terms[0]\n",
       "    for term in terms[1:]:\n",
       "        if term.startswith('-'):\n",
       "            poly_str += f\" {term}\"\n",
       "        else:\n",
       "            poly_str += f\" + {term}\"\n",
       "    return poly_str"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## The HAPD Algorithm (Hermite Algorithm for Periodicity Detection)\n",
       "\n",
       "### Theoretical Foundation\n",
       "\n",
       "**Theorem 1:** The sequence generated by HAPD for input $\\alpha$ is eventually periodic if and only if $\\alpha$ is a cubic irrational.\n",
       "\n",
       "**Definition:** Starting with $(v_1, v_2, v_3) = (\\alpha, \\alpha^2, 1)$, HAPD iteratively computes:\n",
       "\n",
       "1. $a_1 = \\lfloor v_1/v_3 \\rfloor$, $a_2 = \\lfloor v_2/v_3 \\rfloor$.\n",
       "2. $r_1 = v_1 - a_1v_3$, $r_2 = v_2 - a_2v_3$.\n",
       "3. $(v_1, v_2, v_3) \\leftarrow (r_1, r_2, v_3 - a_1r_1 - a_2r_2)$.\n",
       "\n",
       "Each iteration produces a pair $(a_1, a_2)$ that forms the sequence. Viewed projectively as points in $\\mathbb{P}^2(\\mathbb{R})$, the vectors $(v_1:v_2:v_3)$ return to previously visited equivalence classes precisely when $\\alpha$ is cubic."
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "# HAPD Demonstration Function\n",
       "def run_hapd_visualization(alpha, name=\"α\", max_iterations=20):\n",
       "    \"\"\"\n",
       "    Run HAPD on a given number and visualize the results\n",
       "    \"\"\"\n",
       "    print(f\"HAPD Analysis of {name} = {mp.nstr(alpha, 15)}\")\n",
       "    \n",
       "    if not solver_import_successful:\n",
       "        print(\"Cannot run HAPD: solver not available\")\n",
       "        return\n",
       "    \n",
       "    # Run HAPD algorithm\n",
       "    result = hapd_algo.run(alpha)\n",
       "    \n",
       "    # Display main results\n",
       "    print(f\"Classification: {result.get('classification', 'Unknown')}\")\n",
       "    print(f\"Status: {result.get('status', 'Unknown')}\")\n",
       "    is_periodic = result.get('periodic', False)\n",
       "    \n",
       "    if is_periodic:\n",
       "        print(f\"Periodicity detected:\")\n",
       "        print(f\"  • Preperiod length: {result.get('preperiod', 'Unknown')}\")\n",
       "        print(f\"  • Period length: {result.get('period_length', 'Unknown')}\")\n",
       "    else:\n",
       "        print(f\"No periodicity detected after {result.get('iterations', 'Unknown')} iterations\")\n",
       "        if 'note' in result:\n",
       "            print(f\"Note: {result['note']}\")\n",
       "    \n",
       "    # Extract data for visualization\n",
       "    pairs = result.get('pairs', [])\n",
       "    if not pairs:\n",
       "        return result\n",
       "    \n",
       "    # Display the sequence of (a1, a2) pairs\n",
       "    display(Markdown(\"**Sequence of $(a_1, a_2)$ pairs:**\"))\n",
       "    pair_display = \", \".join([f\"({a1}, {a2})\" for a1, a2 in pairs[:min(20, len(pairs))]])\n",
       "    if len(pairs) > 20:\n",
       "        pair_display += \", ...\"\n",
       "    print(pair_display)\n",
       "    \n",
       "    # Visualize the progression in projective space (normalized vectors)\n",
       "    triples = result.get('triples', [])\n",
       "    if triples and len(triples) > 3:\n",
       "        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n",
       "        \n",
       "        # Extract normalized coordinates\n",
       "        norm_triples = []\n",
       "        for triple in triples:\n",
       "            norm = math.sqrt(sum(x*x for x in triple))\n",
       "            if norm > 0:\n",
       "                norm_triples.append(tuple(x/norm for x in triple))\n",
       "            else:\n",
       "                norm_triples.append(triple)\n",
       "        \n",
       "        # Plot projective coordinates (v1/v3, v2/v3)\n",
       "        xs1, ys1 = [], []\n",
       "        for v1, v2, v3 in triples:\n",
       "            if abs(v3) > 1e-10:\n",
       "                xs1.append(v1/v3)\n",
       "                ys1.append(v2/v3)\n",
       "        \n",
       "        # Plot normalized coordinates projection in 2D\n",
       "        xs2, ys2 = [], []\n",
       "        for v1, v2, v3 in norm_triples:\n",
       "            xs2.append(v1)\n",
       "            ys2.append(v2)\n",
       "        \n",
       "        # Actual plotting\n",
       "        if xs1 and ys1:\n",
       "            ax1.scatter(xs1, ys1, c=range(len(xs1)), cmap='viridis', alpha=0.8, s=50)\n",
       "            ax1.plot(xs1, ys1, 'k--', alpha=0.3)\n",
       "            for i, (x, y) in enumerate(zip(xs1, ys1)):\n",
       "                if i < 10 or i % 5 == 0:  # Label selected points\n",
       "                    ax1.annotate(str(i), (x, y), fontsize=9)\n",
       "            ax1.set_title(f\"Projective coordinates $(v_1/v_3, v_2/v_3)$\")\n",
       "            ax1.set_xlabel(\"$v_1/v_3$\")\n",
       "            ax1.set_ylabel(\"$v_2/v_3$\")\n",
       "        \n",
       "        if xs2 and ys2:\n",
       "            ax2.scatter(xs2, ys2, c=range(len(xs2)), cmap='plasma', alpha=0.8, s=50)\n",
       "            ax2.plot(xs2, ys2, 'k--', alpha=0.3)\n",
       "            # Draw lines from origin to points to show projective nature\n",
       "            for i, (x, y) in enumerate(zip(xs2, ys2)):\n",
       "                if i < 10 or i % 5 == 0:\n",
       "                    ax2.annotate(str(i), (x, y), fontsize=9)\n",
       "                if i < 20:  # Only draw some lines for clarity\n",
       "                    ax2.plot([0, x], [0, y], 'r-', alpha=0.1)\n",
       "            ax2.set_title(\"Normalized vectors projection\")\n",
       "            ax2.set_xlabel(\"$v_1/||v||$\")\n",
       "            ax2.set_ylabel(\"$v_2/||v||$\")\n",
       "        \n",
       "        plt.tight_layout()\n",
       "        plt.show()\n",
       "        \n",
       "        # If periodic, visualize the periodicity pattern\n",
       "        if is_periodic and len(pairs) >= result.get('preperiod', 0) + 2*result.get('period_length', 0):\n",
       "            # Extract a1 values for visualization\n",
       "            a1_values = [p[0] for p in pairs]\n",
       "            a2_values = [p[1] for p in pairs]\n",
       "            \n",
       "            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))\n",
       "            \n",
       "            # Plot a1 values\n",
       "            ax1.plot(a1_values, 'bo-', markersize=5, alpha=0.7)\n",
       "            ax1.set_title(f\"$a_1$ values from HAPD sequence\")\n",
       "            ax1.set_xlabel(\"Iteration\")\n",
       "            ax1.set_ylabel(\"$a_1$\")\n",
       "            ax1.grid(True)\n",
       "            \n",
       "            # Mark preperiod and period\n",
       "            if 'preperiod' in result:\n",
       "                preperiod = result['preperiod']\n",
       "                period = result.get('period_length', 0)\n",
       "                ax1.axvline(x=preperiod-0.5, color='r', linestyle='--', alpha=0.7)\n",
       "                for i in range(preperiod, len(a1_values), period):\n",
       "                    ax1.axvline(x=i-0.5, color='g', linestyle='--', alpha=0.3)\n",
       "            \n",
       "            # Plot a2 values\n",
       "            ax2.plot(a2_values, 'ro-', markersize=5, alpha=0.7)\n",
       "            ax2.set_title(f\"$a_2$ values from HAPD sequence\")\n",
       "            ax2.set_xlabel(\"Iteration\")\n",
       "            ax2.set_ylabel(\"$a_2$\")\n",
       "            ax2.grid(True)\n",
       "            \n",
       "            # Mark preperiod and period\n",
       "            if 'preperiod' in result:\n",
       "                ax2.axvline(x=preperiod-0.5, color='r', linestyle='--', alpha=0.7, \n",
       "                           label=f\"Preperiod={preperiod}\")\n",
       "                for i in range(preperiod, len(a2_values), period):\n",
       "                    ax2.axvline(x=i-0.5, color='g', linestyle='--', alpha=0.3)\n",
       "                ax2.axvline(x=preperiod+period-0.5, color='b', linestyle='-.', alpha=0.7,\n",
       "                           label=f\"Period={period}\")\n",
       "                ax2.legend()\n",
       "            \n",
       "            plt.tight_layout()\n",
       "            plt.show()\n",
       "    \n",
       "    return result"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Matrix Approach to Cubic Irrationals\n",
       "\n",
       "### Theoretical Foundation\n",
       "\n",
       "**Theorem 2:** A real number $\\alpha$ is a cubic irrational if and only if there exists a $3 \\times 3$ companion matrix $C$ with rational entries such that the characteristic polynomial of $C$ is irreducible over $\\mathbb{Q}$ and $\\alpha$ is an eigenvalue of $C$.\n",
       "\n",
       "For a cubic irrational with minimal polynomial $p(x) = x^3 + ax^2 + bx + c$, the companion matrix is:\n",
       "\n",
       "$$C_p = \\begin{pmatrix} 0 & 0 & -c \\\\ 1 & 0 & -b \\\\ 0 & 1 & -a \\end{pmatrix}$$\n",
       "\n",
       "Key properties:\n",
       "- Eigenvalues of $C_p$ are precisely the roots of $p(x)$\n",
       "- The trace sequence $t_n = \\text{Tr}(C_p^n) = \\alpha^n + \\beta^n + \\gamma^n$ is integral\n",
       "- Trace sequence satisfies the recurrence relation: $t_k = -a\\cdot t_{k-1} - b\\cdot t_{k-2} - c\\cdot t_{k-3}$ for $k \\geq 3$"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "# Matrix Approach Functions\n",
       "def create_companion_matrix(coeffs):\n",
       "    \"\"\"\n",
       "    Create a companion matrix from polynomial coefficients.\n",
       "    Args:\n",
       "        coeffs: List [a_n, a_{n-1}, ..., a_1, a_0] for polynomial a_n*x^n + ... + a_1*x + a_0\n",
       "    \"\"\"\n",
       "    n = len(coeffs) - 1  # Degree of polynomial\n",
       "    \n",
       "    # Normalize to monic form\n",
       "    leading_coeff = coeffs[0]\n",
       "    normalized_coeffs = [c / leading_coeff for c in coeffs]\n",
       "    \n",
       "    # Create companion matrix\n",
       "    C = np.zeros((n, n))\n",
       "    \n",
       "    # Fill the subdiagonal with 1's\n",
       "    for i in range(1, n):\n",
       "        C[i, i-1] = 1\n",
       "    \n",
       "    # Fill the last column with negated coefficients\n",
       "    for i in range(n):\n",
       "        C[i, n-1] = -normalized_coeffs[n-i]\n",
       "    \n",
       "    return C\n",
       "\n",
       "def compute_trace_sequence(C, max_power=10):\n",
       "    \"\"\"\n",
       "    Compute the trace sequence for powers of matrix C up to max_power\n",
       "    \"\"\"\n",
       "    traces = []\n",
       "    # For power 0, trace is the dimension (trace of identity)\n",
       "    traces.append(C.shape[0])\n",
       "    \n",
       "    # For power 1, simply compute trace\n",
       "    traces.append(np.trace(C))\n",
       "    \n",
       "    # Use matrix power for higher powers\n",
       "    M = C.copy()\n",
       "    for k in range(2, max_power+1):\n",
       "        M = np.dot(M, C)  # M = C^k\n",
       "        traces.append(np.trace(M))\n",
       "    \n",
       "    return traces\n",
       "\n",
       "def verify_trace_recurrence(traces, coeffs):\n",
       "    \"\"\"\n",
       "    Verify the trace recurrence relation for a cubic polynomial\n",
       "    \"\"\"\n",
       "    if len(traces) < 6 or len(coeffs) != 4:\n",
       "        return False\n",
       "    \n",
       "    # For cubic with x^3 + ax^2 + bx + c, the relation is:\n",
       "    # tr(C^k) = -a*tr(C^(k-1)) - b*tr(C^(k-2)) - c*tr(C^(k-3))\n",
       "    a, b, c = -coeffs[1]/coeffs[0], -coeffs[2]/coeffs[0], -coeffs[3]/coeffs[0]\n",
       "    \n",
       "    verification_results = []\n",
       "    for k in range(3, len(traces)):\n",
       "        expected = -a * traces[k-1] - b * traces[k-2] - c * traces[k-3]\n",
       "        actual = traces[k]\n",
       "        error = abs(expected - actual)\n",
       "        verification_results.append({\n",
       "            'k': k,\n",
       "            'expected': expected,\n",
       "            'actual': actual,\n",
       "            'error': error,\n",
       "            'verified': error < 1e-10\n",
       "        })\n",
       "    \n",
       "    return verification_results\n",
       "\n",
       "def matrix_cubic_verification(alpha, coeffs=None, tolerance=1e-10, visualize=True):\n",
       "    \"\"\"\n",
       "    Verify if alpha is a cubic irrational using matrix approach\n",
       "    \"\"\"\n",
       "    print(f\"Matrix Verification for α = {mp.nstr(alpha, 15)}\")\n",
       "    \n",
       "    # If coefficients not provided, try to find them\n",
       "    if coeffs is None:\n",
       "        if solver_import_successful:\n",
       "            coeffs = Utils.find_minimal_polynomial(alpha, max_degree=3)\n",
       "        else:\n",
       "            # Special cases for demonstration\n",
       "            if abs(alpha - mp.cbrt(2)) < 1e-10:\n",
       "                coeffs = [1, 0, 0, -2]  # x^3 - 2\n",
       "            elif abs(alpha - mp.cbrt(3)) < 1e-10:\n",
       "                coeffs = [1, 0, 0, -3]  # x^3 - 3\n",
       "            elif abs(alpha - mp.sqrt(2)) < 1e-10:\n",
       "                coeffs = [1, 0, -2]     # x^2 - 2\n",
       "            else:\n",
       "                print(\"Cannot determine minimal polynomial for demonstration.\")\n",
       "                return None\n",
       "    \n",
       "    if coeffs is None:\n",
       "        print(\"Could not find minimal polynomial.\")\n",
       "        return None\n",
       "    \n",
       "    # Print the polynomial\n",
       "    poly_str = format_polynomial(coeffs)\n",
       "    print(f\"Minimal polynomial: {poly_str} = 0\")\n",
       "    print(f\"Degree: {len(coeffs)-1}\")\n",
       "    \n",
       "    # For non-cubic polynomials, just return the basic info\n",
       "    if len(coeffs) != 4:  # Not a cubic polynomial\n",
       "        print(f\"Not a cubic polynomial (degree {len(coeffs)-1})\")\n",
       "        classification = \"quadratic_irrational\" if len(coeffs) == 3 else \"not_cubic\"\n",
       "        return {\n",
       "            \"classification\": classification,\n",
       "            \"polynomial\": coeffs,\n",
       "            \"degree\": len(coeffs)-1\n",
       "        }\n",
       "    \n",
       "    # Create companion matrix\n",
       "    C = create_companion_matrix(coeffs)\n",
       "    print(f\"\\nCompanion Matrix C:\\n{C}\")\n",
       "    \n",
       "    # Compute eigenvalues\n",
       "    eigenvalues = np.linalg.eigvals(C)\n",
       "    print(f\"\\nEigenvalues of C:\\n{eigenvalues}\")\n",
       "    \n",
       "    # Check if alpha is an eigenvalue\n",
       "    is_eigenvalue = any(abs(complex(alpha) - ev) < tolerance for ev in eigenvalues)\n",
       "    print(f\"Is α an eigenvalue? {is_eigenvalue}\")\n",
       "    \n",
       "    # Compute trace sequence\n",
       "    traces = compute_trace_sequence(C, max_power=10)\n",
       "    \n",
       "    # Verify trace recurrence relation\n",
       "    verification_results = verify_trace_recurrence(traces, coeffs)\n",
       "    \n",
       "    all_verified = all(result[\"verified\"] for result in verification_results)\n",
       "    print(f\"\\nTrace recurrence relations verified: {all_verified}\")\n",
       "    \n",
       "    # Print trace sequence\n",
       "    print(f\"\\nTrace Sequence (t₀ to t₁₀):\")\n",
       "    for i, trace in enumerate(traces):\n",
       "        print(f\"  t_{i} = {trace:.4f}\")\n",
       "    \n",
       "    # Print verification results\n",
       "    print(\"\\nTrace Relation Verification:\")\n",
       "    for result in verification_results:\n",
       "        print(f\"  k={result['k']}: Expected={result['expected']:.4f}, Actual={result['actual']:.4f}, \"  \n",
       "              f\"Error={result['error']:.2e}, Verified={result['verified']}\")\n",
       "    \n",
       "    # Evaluate polynomial at alpha\n",
       "    poly_value = 0\n",
       "    alpha_power = 1\n",
       "    for i in range(len(coeffs)-1, -1, -1):\n",
       "        poly_value += coeffs[i] * alpha_power\n",
       "        alpha_power *= alpha\n",
       "    \n",
       "    is_root = abs(poly_value) < tolerance\n",
       "    print(f\"\\nIs α a root of the polynomial? {is_root} (p(α) = {poly_value:.2e})\")\n",
       "    \n",
       "    # Classification based on all checks\n",
       "    if is_root and all_verified and len(coeffs) == 4:\n",
       "        classification = \"cubic_irrational\"\n",
       "    else:\n",
       "        classification = \"not_cubic\"\n",
       "    \n",
       "    # Visualization\n",
       "    if visualize and len(traces) >= 5:\n",
       "        plt.figure(figsize=(10, 6))\n",
       "        plt.plot(range(len(traces)), traces, 'bo-', markersize=8)\n",
       "        plt.title(f\"Trace Sequence for $C^k$ where C is companion matrix of {poly_str}\")\n",
       "        plt.xlabel(\"k\")\n",
       "        plt.ylabel(\"$\\\\text{{Tr}}(C^k)$\")\n",
       "        plt.grid(True)\n",
       "        \n",
       "        # Add annotations for the recurrence relation\n",
       "        if len(coeffs) == 4:\n",
       "            a, b, c = -coeffs[1]/coeffs[0], -coeffs[2]/coeffs[0], -coeffs[3]/coeffs[0]\n",
       "            recurrence_latex = f\"$t_k = {-a:.2f} \\\\cdot t_{{k-1}} {-b:+.2f} \\\\cdot t_{{k-2}} {-c:+.2f} \\\\cdot t_{{k-3}}$\"\n",
       "            plt.annotate(recurrence_latex, xy=(0.5, 0.95), xycoords='axes fraction', \n",
       "                         ha='center', va='top', bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", alpha=0.8))\n",
       "        \n",
       "        plt.tight_layout()\n",
       "        plt.show()\n",
       "        \n",
       "        # If it's cubic, visualize the eigenvalues in the complex plane\n",
       "        if len(coeffs) == 4:\n",
       "            plt.figure(figsize=(8, 8))\n",
       "            real_parts = [ev.real for ev in eigenvalues]\n",
       "            imag_parts = [ev.imag for ev in eigenvalues]\n",
       "            \n",
       "            plt.scatter(real_parts, imag_parts, s=100, c='r', marker='x')\n",
       "            plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)\n",
       "            plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)\n",
       "            \n",
       "            # Add a unit circle for reference\n",
       "            theta = np.linspace(0, 2*np.pi, 100)\n",
       "            plt.plot(np.cos(theta), np.sin(theta), 'k--', alpha=0.3)\n",
       "            \n",
       "            # Highlight the point closest to alpha\n",
       "            alpha_idx = np.argmin([abs(complex(alpha) - ev) for ev in eigenvalues])\n",
       "            plt.scatter([real_parts[alpha_idx]], [imag_parts[alpha_idx]], \n",
       "                        s=150, facecolors='none', edgecolors='blue', linewidths=2)\n",
       "            \n",
       "            # Annotate points\n",
       "            for i, (x, y) in enumerate(zip(real_parts, imag_parts)):\n",
       "                if abs(y) < 1e-10:  # Real eigenvalue\n",
       "                    label = f\"λ_{i+1}={x:.4f}\"\n",
       "                else:  # Complex eigenvalue\n",
       "                    label = f\"λ_{i+1}={x:.4f}{y:+.4f}i\"\n",
       "                plt.annotate(label, (x, y), xytext=(10, 10), textcoords='offset points')\n",
       "            \n",
       "            plt.axis('equal')\n",
       "            plt.title(\"Eigenvalues of the companion matrix in the complex plane\")\n",
       "            plt.xlabel(\"Re(λ)\")\n",
       "            plt.ylabel(\"Im(λ)\")\n",
       "            plt.grid(True)\n",
       "            plt.tight_layout()\n",
       "            plt.show()\n",
       "    \n",
       "    result = {\n",
       "        \"classification\": classification,\n",
       "        \"polynomial\": coeffs,\n",
       "        \"traces\": traces,\n",
       "        \"verification_results\": verification_results,\n",
       "        \"verification_success\": all_verified,\n",
       "        \"is_root\": is_root,\n",
       "        \"eigenvalues\": eigenvalues.tolist() if isinstance(eigenvalues, np.ndarray) else eigenvalues,\n",
       "        \"poly_value\": float(poly_value)\n",
       "    }\n",
       "    \n",
       "    return result"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Modified Sin²-Algorithm for Complex Conjugate Roots\n",
       "\n",
       "### Theoretical Foundation\n",
       "\n",
       "Karpenkov's sin²-algorithm characterizes totally real cubic irrationals. Our modification extends it to handle complex conjugate roots by implementing a phase-preserving floor function.\n",
       "\n",
       "For a cubic irrational $\\alpha$ with minimal polynomial $p(x) = x^3 + ax^2 + bx + c$, we work in the 3D space $(v_1, v_2, v_3)$ but use a modified floor function that respects the algebraic structure when roots are complex."
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "# Implementation of the Modified Sin²-Algorithm\n",
       "def phase_preserving_floor(x, y):\n",
       "    \"\"\"\n",
       "    Implement a phase-preserving floor function for complex conjugate treatment\n",
       "    Args:\n",
       "        x, y: Real values representing the real and imaginary parts\n",
       "    Returns:\n",
       "        Tuple of integers (a, b) representing the phase-preserving floor\n",
       "    \"\"\"\n",
       "    # Basic implementation for demonstration\n",
       "    # In practice, this would consider the Galois action on complex conjugate roots\n",
       "    magnitude = math.sqrt(x*x + y*y)\n",
       "    if magnitude < 1e-10:\n",
       "        return (0, 0)\n",
       "    \n",
       "    # Compute angle in [0, 2π)\n",
       "    angle = math.atan2(y, x)\n",
       "    if angle < 0:\n",
       "        angle += 2 * math.pi\n",
       "    \n",
       "    # Determine sector (dividing the plane into 8 sectors)\n",
       "    sector = int(angle / (math.pi/4))\n",
       "    \n",
       "    # Base floor values\n",
       "    a = math.floor(x)\n",
       "    b = math.floor(y)\n",
       "    \n",
       "    # Adjust based on sector to maintain phase properties\n",
       "    if sector == 0 or sector == 4:  # Along positive or negative real axis\n",
       "        return (a, 0)\n",
       "    elif sector == 2 or sector == 6:  # Along positive or negative imaginary axis\n",
       "        return (0, b)\n",
       "    else:  # In quadrants\n",
       "        return (a, b)\n",
       "\n",
       "def sin2_algorithm(alpha, max_iterations=50, tolerance=1e-15):\n",
       "    \"\"\"\n",
       "    Implement the modified sin²-algorithm for cubic irrationals\n",
       "    \"\"\"\n",
       "    if not solver_import_successful:\n",
       "        print(\"Demonstration mode: Using simplified implementation\")\n",
       "    \n",
       "    # First determine the minimal polynomial\n",
       "    poly = None\n",
       "    if solver_import_successful:\n",
       "        poly = Utils.find_minimal_polynomial(alpha, max_degree=3)\n",
       "    else:\n",
       "        # Special cases for demonstration\n",
       "        if abs(alpha - mp.cbrt(2)) < 1e-10:\n",
       "            poly = [1, 0, 0, -2]  # x^3 - 2\n",
       "        elif abs(alpha - mp.cbrt(3)) < 1e-10:\n",
       "            poly = [1, 0, 0, -3]  # x^3 - 3\n",
       "        elif abs(alpha - find_real_root_of_x3_plus_x_plus_1()) < 1e-10:\n",
       "            poly = [1, 0, 1, 1]   # x^3 + x + 1\n",
       "    \n",
       "    if poly is None or len(poly) != 4:\n",
       "        print(\"Cannot determine suitable cubic minimal polynomial.\")\n",
       "        return {\"status\": \"failed\", \"reason\": \"No suitable polynomial found\"}\n",
       "    \n",
       "    # Determine if polynomial has complex conjugate roots\n",
       "    a, b, c = poly[1]/poly[0], poly[2]/poly[0], poly[3]/poly[0]\n",
       "    discriminant = 18*a*b*c - 27*c*c - 4*b*b*b - 4*a*a*a*c + a*a*b*b\n",
       "    has_complex_roots = discriminant < 0\n",
       "    \n",
       "    print(f\"Minimal polynomial: {format_polynomial(poly)} = 0\")\n",
       "    print(f\"Discriminant: {discriminant:.4e}\")\n",
       "    print(f\"Has complex conjugate roots: {has_complex_roots}\")\n",
       "    \n",
       "    # Initialize the algorithm\n",
       "    v1 = float(alpha)\n",
       "    v2 = float(alpha * alpha)\n",
       "    v3 = 1.0\n",
       "    \n",
       "    history = []\n",
       "    floor_pairs = []\n",
       "    \n",
       "    # Main algorithm loop\n",
       "    for i in range(max_iterations):\n",
       "        # Store current state\n",
       "        current = (v1, v2, v3)\n",
       "        history.append(current)\n",
       "        \n",
       "        # Compute phase-preserving floor for complex cases, regular for real\n",
       "        if has_complex_roots:\n",
       "            # Here we use v1/v3 and v2/v3 as real and imag parts for demonstration\n",
       "            a1, a2 = phase_preserving_floor(v1/v3, v2/v3)\n",
       "        else:\n",
       "            # Standard floor for totally real case\n",
       "            a1 = math.floor(v1/v3)\n",
       "            a2 = math.floor(v2/v3)\n",
       "        \n",
       "        floor_pairs.append((a1, a2))\n",
       "        \n",
       "        # Calculate remainders\n",
       "        r1 = v1 - a1*v3\n",
       "        r2 = v2 - a2*v3\n",
       "        \n",
       "        # Modified update rule depending on the root type\n",
       "        if has_complex_roots:\n",
       "            # Phase-preserving transformation for complex case\n",
       "            new_v3 = v3 - a1*r1 - a2*r2\n",
       "            # Ensure some additional constraints for complex stability\n",
       "            if abs(new_v3) < tolerance:\n",
       "                break\n",
       "        else:\n",
       "            # Standard update for totally real case\n",
       "            new_v3 = v3 - a1*r1 - a2*r2\n",
       "        \n",
       "        # Update for next iteration\n",
       "        v1, v2, v3 = r1, r2, new_v3\n",
       "        \n",
       "        # Detect periodicity by comparing normalized vectors\n",
       "        norm_current = math.sqrt(r1*r1 + r2*r2 + new_v3*new_v3)\n",
       "        if norm_current < tolerance:\n",
       "            break\n",
       "        \n",
       "        # Check for periodicity\n",
       "        for j in range(len(history) - 1):\n",
       "            prev = history[j]\n",
       "            # Normalize both vectors\n",
       "            norm_prev = math.sqrt(prev[0]*prev[0] + prev[1]*prev[1] + prev[2]*prev[2])\n",
       "            prev_normalized = (prev[0]/norm_prev, prev[1]/norm_prev, prev[2]/norm_prev)\n",
       "            current_normalized = (r1/norm_current, r2/norm_current, new_v3/norm_current)\n",
       "            \n",
       "            # Check if vectors are projectively equivalent\n",
       "            dot_product = abs(prev_normalized[0]*current_normalized[0] + \n",
       "                             prev_normalized[1]*current_normalized[1] + \n",
       "                             prev_normalized[2]*current_normalized[2])\n",
       "            \n",
       "            if abs(dot_product - 1.0) < tolerance:\n",
       "                # Found periodicity\n",
       "                period = i - j\n",
       "                preperiod = j\n",
       "                return {\n",
       "                    \"status\": \"periodic\",\n",
       "                    \"preperiod\": preperiod,\n",
       "                    \"period\": period,\n",
       "                    \"floor_pairs\": floor_pairs,\n",
       "                    \"has_complex_roots\": has_complex_roots,\n",
       "                    \"discriminant\": discriminant\n",
       "                }\n",
       "    \n",
       "    # If no periodicity detected\n",
       "    return {\n",
       "        \"status\": \"not_periodic\",\n",
       "        \"iterations\": len(history),\n",
       "        \"floor_pairs\": floor_pairs,\n",
       "        \"has_complex_roots\": has_complex_roots,\n",
       "        \"discriminant\": discriminant\n",
       "    }\n",
       "\n",
       "def visualize_sin2_result(result, alpha, name):\n",
       "    \"\"\"\n",
       "    Visualize results from Sin²-algorithm\n",
       "    \"\"\"\n",
       "    print(f\"Sin²-Algorithm Results for {name} = {mp.nstr(alpha, 15)}\")\n",
       "    print(f\"Status: {result['status']}\")\n",
       "    \n",
       "    if result['status'] == 'periodic':\n",
       "        print(f\"Preperiod: {result['preperiod']}\")\n",
       "        print(f\"Period: {result['period']}\")\n",
       "    else:\n",
       "        print(f\"Iterations without detecting periodicity: {result['iterations']}\")\n",
       "    \n",
       "    print(f\"Has complex conjugate roots: {result['has_complex_roots']}\")\n",
       "    print(f\"Discriminant: {result['discriminant']:.4e}\")\n",
       "    \n",
       "    # Visualize the floor pairs\n",
       "    floor_pairs = result.get('floor_pairs', [])\n",
       "    if floor_pairs:\n",
       "        # Extract for plotting\n",
       "        a1_values = [p[0] for p in floor_pairs]\n",
       "        a2_values = [p[1] for p in floor_pairs]\n",
       "        \n",
       "        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))\n",
       "        \n",
       "        # Plot a1 values\n",
       "        ax1.plot(a1_values, 'bo-', markersize=5, alpha=0.7)\n",
       "        ax1.set_title(f\"$a_1$ values from Sin²-algorithm sequence\")\n",
       "        ax1.set_xlabel(\"Iteration\")\n",
       "        ax1.set_ylabel(\"$a_1$\")\n",
       "        ax1.grid(True)\n",
       "        \n",
       "        # Mark preperiod and period if periodic\n",
       "        if result['status'] == 'periodic':\n",
       "            preperiod = result['preperiod']\n",
       "            period = result['period']\n",
       "            ax1.axvline(x=preperiod-0.5, color='r', linestyle='--', alpha=0.7, \n",
       "                      label=f\"Preperiod={preperiod}\")\n",
       "            ax1.axvline(x=preperiod+period-0.5, color='g', linestyle='--', alpha=0.7,\n",
       "                      label=f\"Period={period}\")\n",
       "            ax1.legend()\n",
       "        \n",
       "        # Plot a2 values\n",
       "        ax2.plot(a2_values, 'ro-', markersize=5, alpha=0.7)\n",
       "        ax2.set_title(f\"$a_2$ values from Sin²-algorithm sequence\")\n",
       "        ax2.set_xlabel(\"Iteration\")\n",
       "        ax2.set_ylabel(\"$a_2$\")\n",
       "        ax2.grid(True)\n",
       "        \n",
       "        # Mark preperiod and period if periodic\n",
       "        if result['status'] == 'periodic':\n",
       "            ax2.axvline(x=preperiod-0.5, color='r', linestyle='--', alpha=0.7, \n",
       "                      label=f\"Preperiod={preperiod}\")\n",
       "            ax2.axvline(x=preperiod+period-0.5, color='g', linestyle='--', alpha=0.7,\n",
       "                      label=f\"Period={period}\")\n",
       "            ax2.legend()\n",
       "        \n",
       "        plt.tight_layout()\n",
       "        plt.show()\n",
       "        \n",
       "        # Visualize the floor pairs in 2D plane\n",
       "        if len(floor_pairs) > 1:\n",
       "            plt.figure(figsize=(8, 8))\n",
       "            # Create colormap based on iteration number\n",
       "            colors = plt.cm.viridis(np.linspace(0, 1, len(floor_pairs)))\n",
       "            \n",
       "            # Scatter plot of floor pairs\n",
       "            for i, ((a1, a2), color) in enumerate(zip(floor_pairs, colors)):\n",
       "                plt.scatter(a1, a2, color=color, s=100, alpha=0.7)\n",
       "                plt.annotate(str(i), (a1, a2), xytext=(5, 5), textcoords='offset points')\n",
       "            \n",
       "            # Connect points in sequence\n",
       "            plt.plot([p[0] for p in floor_pairs], [p[1] for p in floor_pairs], 'k-', alpha=0.3)\n",
       "            \n",
       "            # Mark the preperiod and period\n",
       "            if result['status'] == 'periodic':\n",
       "                preperiod = result['preperiod']\n",
       "                period = result['period']\n",
       "                \n",
       "                # Highlight the periodic part\n",
       "                periodic_pairs = floor_pairs[preperiod:preperiod+period]\n",
       "                if periodic_pairs:\n",
       "                    periodic_x = [p[0] for p in periodic_pairs]\n",
       "                    periodic_y = [p[1] for p in periodic_pairs]\n",
       "                    plt.plot(periodic_x, periodic_y, 'r-', linewidth=2, alpha=0.7)\n",
       "                    \n",
       "                    # Connect back to start of period\n",
       "                    plt.plot([periodic_pairs[-1][0], periodic_pairs[0][0]], \n",
       "                             [periodic_pairs[-1][1], periodic_pairs[0][1]], \n",
       "                             'r--', linewidth=2, alpha=0.7)\n",
       "            \n",
       "            plt.title(f\"Floor pairs $(a_1, a_2)$ from Sin²-algorithm for {name}\")\n",
       "            plt.xlabel(\"$a_1$\")\n",
       "            plt.ylabel(\"$a_2$\")\n",
       "            plt.grid(True)\n",
       "            plt.axis('equal')\n",
       "            plt.tight_layout()\n",
       "            plt.show()\n",
       "            \n",
       "    return result"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Combined Approach and Comparative Analysis\n",
       "\n",
       "We can now provide a comprehensive analysis that combines all three methods:\n",
       "1. HAPD Algorithm\n",
       "2. Matrix Approach\n",
       "3. Modified Sin²-Algorithm\n",
       "\n",
       "This combined approach offers robust cubic irrational detection with multiple verification techniques."
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "def comprehensive_cubic_analysis(alpha, name=\"α\", visualize=True):\n",
       "    \"\"\"\n",
       "    Perform a comprehensive analysis using all three methods\n",
       "    \"\"\"\n",
       "    print(f\"=============== Comprehensive Analysis of {name} = {mp.nstr(alpha, 15)} ===============\")\n",
       "    \n",
       "    # Find minimal polynomial if possible\n",
       "    poly = None\n",
       "    if solver_import_successful:\n",
       "        poly = Utils.find_minimal_polynomial(alpha, max_degree=3)\n",
       "    else:\n",
       "        # Special cases for demonstration\n",
       "        if abs(alpha - mp.cbrt(2)) < 1e-10:\n",
       "            poly = [1, 0, 0, -2]  # x^3 - 2\n",
       "        elif abs(alpha - mp.cbrt(3)) < 1e-10:\n",
       "            poly = [1, 0, 0, -3]  # x^3 - 3\n",
       "        elif abs(alpha - mp.sqrt(2)) < 1e-10:\n",
       "            poly = [1, 0, -2]     # x^2 - 2\n",
       "    \n",
       "    if poly is not None:\n",
       "        print(f\"Minimal polynomial: {format_polynomial(poly)} = 0\")\n",
       "        print(f\"Degree: {len(poly)-1}\")\n",
       "        \n",
       "        # For cubic, compute discriminant\n",
       "        if len(poly) == 4:\n",
       "            a, b, c = poly[1]/poly[0], poly[2]/poly[0], poly[3]/poly[0]\n",
       "            discriminant = 18*a*b*c - 27*c*c - 4*b*b*b - 4*a*a*a*c + a*a*b*b\n",
       "            print(f\"Discriminant: {discriminant:.4e}\")\n",
       "            print(f\"Has complex conjugate roots: {discriminant < 0}\")\n",
       "    else:\n",
       "        print(\"Could not determine minimal polynomial\")\n",
       "    \n",
       "    # Run all three methods if solver is available\n",
       "    results = {}\n",
       "    \n",
       "    # Method 1: HAPD Algorithm\n",
       "    if solver_import_successful:\n",
       "        print(\"\\n--- Method 1: HAPD Algorithm ---\")\n",
       "        hapd_result = hapd_algo.run(alpha)\n",
       "        results['hapd'] = hapd_result\n",
       "        print(f\"Classification: {hapd_result.get('classification', 'Unknown')}\")\n",
       "        print(f\"Status: {hapd_result.get('status', 'Unknown')}\")\n",
       "        if hapd_result.get('periodic', False):\n",
       "            print(f\"Periodicity detected:\")\n",
       "            print(f\"  • Preperiod length: {hapd_result.get('preperiod', 'Unknown')}\")\n",
       "            print(f\"  • Period length: {hapd_result.get('period_length', 'Unknown')}\")\n",
       "    else:\n",
       "        print(\"\\n--- Method 1: HAPD Algorithm (Not Available) ---\")\n",
       "    \n",
       "    # Method 2: Matrix Approach\n",
       "    print(\"\\n--- Method 2: Matrix Approach ---\")\n",
       "    if poly is not None and len(poly) <= 4:  # Can only handle up to cubic\n",
       "        matrix_result = matrix_cubic_verification(alpha, coeffs=poly, visualize=False)\n",
       "        results['matrix'] = matrix_result\n",
       "        if matrix_result:\n",
       "            print(f\"Classification: {matrix_result.get('classification', 'Unknown')}\")\n",
       "            print(f\"Verification Success: {matrix_result.get('verification_success', False)}\")\n",
       "            print(f\"Is Root: {matrix_result.get('is_root', False)}\")\n",
       "    else:\n",
       "        print(\"Cannot perform matrix verification without appropriate polynomial\")\n",
       "    \n",
       "    # Method 3: Sin² Algorithm\n",
       "    print(\"\\n--- Method 3: Modified Sin²-Algorithm ---\")\n",
       "    sin2_result = sin2_algorithm(alpha, max_iterations=30)\n",
       "    results['sin2'] = sin2_result\n",
       "    print(f\"Status: {sin2_result.get('status', 'Unknown')}\")\n",
       "    if sin2_result.get('status') == 'periodic':\n",
       "        print(f\"Preperiod: {sin2_result.get('preperiod', 'Unknown')}\")\n",
       "        print(f\"Period: {sin2_result.get('period', 'Unknown')}\")\n",
       "    \n",
       "    # Unified Classification\n",
       "    classifications = []\n",
       "    if 'hapd' in results and results['hapd'].get('classification') == 'cubic_irrational':\n",
       "        classifications.append('cubic_irrational')\n",
       "    if 'matrix' in results and results['matrix'].get('classification') == 'cubic_irrational':\n",
       "        classifications.append('cubic_irrational')\n",
       "    if 'sin2' in results and sin2_result.get('status') == 'periodic':\n",
       "        classifications.append('cubic_irrational')\n",
       "    \n",
       "    # For quadratic classification\n",
       "    if poly is not None and len(poly) == 3:  # Degree 2\n",
       "        classifications.append('quadratic_irrational')\n",
       "    \n",
       "    # Final classification with confidence\n",
       "    final_classification = \"undetermined\"\n",
       "    confidence = \"low\"\n",
       "    \n",
       "    if 'cubic_irrational' in classifications:\n",
       "        count = classifications.count('cubic_irrational')\n",
       "        if count >= 2:\n",
       "            final_classification = \"cubic_irrational\"\n",
       "            confidence = \"high\" if count == 3 else \"medium\"\n",
       "        else:\n",
       "            final_classification = \"cubic_irrational\"\n",
       "            confidence = \"low\"\n",
       "    elif 'quadratic_irrational' in classifications:\n",
       "        final_classification = \"quadratic_irrational\"\n",
       "        confidence = \"medium\"\n",
       "    \n",
       "    print(f\"\\n====== Final Classification ======\")\n",
       "    print(f\"Classification: {final_classification}\")\n",
       "    print(f\"Confidence: {confidence}\")\n",
       "    \n",
       "    # Create comparative visualization if requested\n",
       "    if visualize and poly is not None:\n",
       "        # Period comparison if relevant\n",
       "        periods = []\n",
       "        methods = []\n",
       "        \n",
       "        if 'hapd' in results and results['hapd'].get('periodic', False):\n",
       "            periods.append(results['hapd'].get('period_length', 0))\n",
       "            methods.append('HAPD')\n",
       "            \n",
       "        if 'sin2' in results and sin2_result.get('status') == 'periodic':\n",
       "            periods.append(sin2_result.get('period', 0))\n",
       "            methods.append('Sin²')\n",
       "            \n",
       "        if periods and methods:\n",
       "            plt.figure(figsize=(8, 5))\n",
       "            plt.bar(methods, periods, color='skyblue')\n",
       "            plt.title(f\"Period Length Comparison for {name}\")\n",
       "            plt.ylabel(\"Period Length\")\n",
       "            plt.grid(axis='y', linestyle='--', alpha=0.7)\n",
       "            \n",
       "            for i, v in enumerate(periods):\n",
       "                plt.text(i, v + 0.5, str(v), ha='center')\n",
       "                \n",
       "            plt.tight_layout()\n",
       "            plt.show()\n",
       "    \n",
       "    return {\n",
       "        \"name\": name,\n",
       "        \"value\": alpha,\n",
       "        \"polynomial\": poly,\n",
       "        \"degree\": len(poly)-1 if poly else None,\n",
       "        \"classification\": final_classification,\n",
       "        \"confidence\": confidence,\n",
       "        \"results\": results\n",
       "    }"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Conclusion\n",
       "\n",
       "This notebook has demonstrated a complete solution to Hermite's problem for cubic irrationals, including those with complex conjugate roots. The key contributions include:\n",
       "\n",
       "1. **HAPD Algorithm**: A projective space approach yielding periodicity if and only if the input is a cubic irrational, with theoretical proof of correctness for all cubic irrationals regardless of root structure.\n",
       "\n",
       "2. **Matrix Approach**: A companion matrix characterization with trace sequence properties that offers an alternative verification mechanism with direct connection to Galois theory.\n",
       "\n",
       "3. **Modified Sin²-Algorithm**: An extension of Karpenkov's work that handles cubic irrationals with complex conjugate roots through phase-preserving floor functions.\n",
       "\n",
       "The comparative analysis demonstrates that these methods complement each other, with varying strengths in handling different types of cubic irrationals. The Matrix Approach typically offers the fastest verification when a candidate minimal polynomial is available, while HAPD excels at detection without prior knowledge of the minimal polynomial.\n",
       "\n",
       "These approaches generalize to number fields of higher degree, potentially leading to characterizations of algebraic irrationals of arbitrary degree through periodicity in appropriate representation spaces.\n",
       "\n",
       "**Theoretical Significance**: The solution connects Hermite's problem to projective geometry, providing a natural framework for understanding the periodicity phenomenon. It also establishes links to Dirichlet group actions and ergodic theory.\n",
       "\n",
       "**Practical Applications**: Beyond pure mathematics, these algorithms have applications in integer relation detection, lattice reduction, and numerical analysis of algebraic numbers."
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "# Example 1: HAPD analysis of cubic irrational ∛2\n",
       "alpha_cubic = mp.cbrt(2)\n",
       "hapd_result_cubic = run_hapd_visualization(alpha_cubic, name=\"∛2\")"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "# Example 2: HAPD analysis of cubic irrational with complex conjugate roots\n",
       "# x^3 + x + 1 has negative discriminant, hence complex conjugate roots\n",
       "def find_real_root_of_x3_plus_x_plus_1():\n",
       "    if solver_import_successful:\n",
       "        return Utils.find_real_root([1, 0, 1, 1])\n",
       "    else:\n",
       "        # Approximate real root of x^3 + x + 1 = 0\n",
       "        return -0.6823278038280193\n",
       "\n",
       "alpha_complex_cubic = find_real_root_of_x3_plus_x_plus_1()\n",
       "hapd_result_complex = run_hapd_visualization(\n",
       "    alpha_complex_cubic, \n",
       "    name=\"Root of x³+x+1\"\n",
       ")"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "# Example 3: HAPD analysis of non-cubic number (quadratic irrational √2)\n",
       "alpha_quadratic = mp.sqrt(2)\n",
       "hapd_result_quadratic = run_hapd_visualization(alpha_quadratic, name=\"√2\")"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "# Example 4: HAPD analysis of transcendental number (π)\n",
       "alpha_transcendental = mp.pi\n",
       "hapd_result_transcendental = run_hapd_visualization(alpha_transcendental, name=\"π\")"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "# Example 1: Matrix verification for ∛2 (a totally real cubic irrational)\n",
       "matrix_result_cubic = matrix_cubic_verification(mp.cbrt(2), coeffs=[1, 0, 0, -2])"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "# Example 2: Matrix verification for a cubic with complex conjugate roots\n",
       "# For x^3 + x + 1 = 0\n",
       "matrix_result_complex = matrix_cubic_verification(\n",
       "    find_real_root_of_x3_plus_x_plus_1(), \n",
       "    coeffs=[1, 0, 1, 1]\n",
       ")"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "# Example 3: Matrix verification for √2 (quadratic irrational)\n",
       "matrix_result_quadratic = matrix_cubic_verification(mp.sqrt(2), coeffs=[1, 0, -2])"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "# Comprehensive analysis of various number types\n",
       "test_numbers = [\n",
       "    {\"name\": \"∛2\", \"value\": mp.cbrt(2)},\n",
       "    {\"name\": \"Root of x³+x+1\", \"value\": find_real_root_of_x3_plus_x_plus_1()},\n",
       "    {\"name\": \"√2\", \"value\": mp.sqrt(2)},\n",
       "    {\"name\": \"π\", \"value\": mp.pi}\n",
       "]\n",
       "\n",
       "for test in test_numbers:\n",
       "    comprehensive_cubic_analysis(test[\"value\"], test[\"name\"])"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Performance Analysis and Method Comparison\n",
       "\n",
       "The three methods presented (HAPD, Matrix Approach, and Modified Sin²-Algorithm) offer different advantages and have varying performance characteristics. This section compares their computational efficiency, accuracy, and applicability to different types of cubic irrationals."
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "import time\n",
       "\n",
       "def performance_comparison(test_numbers=None, iterations=3):\n",
       "    \"\"\"\n",
       "    Compare performance of different methods\n",
       "    \"\"\"\n",
       "    if test_numbers is None:\n",
       "        # Default test cases if none provided\n",
       "        test_numbers = [\n",
       "            {\"name\": \"∛2\", \"value\": mp.cbrt(2), \"type\": \"totally_real_cubic\"},\n",
       "            {\"name\": \"∛3\", \"value\": mp.cbrt(3), \"type\": \"totally_real_cubic\"},\n",
       "            {\"name\": \"Root of x³+x+1\", \"value\": find_real_root_of_x3_plus_x_plus_1(), \n",
       "             \"type\": \"complex_roots_cubic\"},\n",
       "            {\"name\": \"√2\", \"value\": mp.sqrt(2), \"type\": \"quadratic\"},\n",
       "            {\"name\": \"π\", \"value\": mp.pi, \"type\": \"transcendental\"}\n",
       "        ]\n",
       "    \n",
       "    # Skip this if solver not available\n",
       "    if not solver_import_successful:\n",
       "        print(\"Full solver not available for performance comparison\")\n",
       "        return\n",
       "    \n",
       "    results = []\n",
       "    \n",
       "    for test in test_numbers:\n",
       "        alpha = test[\"value\"]\n",
       "        name = test[\"name\"]\n",
       "        alpha_type = test.get(\"type\", \"unknown\")\n",
       "        \n",
       "        print(f\"Testing {name} ({alpha_type})...\")\n",
       "        \n",
       "        # 1. HAPD Algorithm\n",
       "        hapd_times = []\n",
       "        hapd_result = None\n",
       "        for _ in range(iterations):\n",
       "            start = time.time()\n",
       "            hapd_result = hapd_algo.run(alpha)\n",
       "            end = time.time()\n",
       "            hapd_times.append(end - start)\n",
       "        hapd_avg_time = sum(hapd_times) / len(hapd_times)\n",
       "        \n",
       "        # 2. Matrix Approach\n",
       "        matrix_times = []\n",
       "        matrix_result = None\n",
       "        # Find polynomial first\n",
       "        poly = Utils.find_minimal_polynomial(alpha, max_degree=3)\n",
       "        if poly is not None and len(poly) <= 4:  # Can only handle up to cubic\n",
       "            for _ in range(iterations):\n",
       "                start = time.time()\n",
       "                matrix_result = matrix_algo.verify_cubic_irrational(alpha, candidate_poly=poly)\n",
       "                end = time.time()\n",
       "                matrix_times.append(end - start)\n",
       "        matrix_avg_time = sum(matrix_times) / len(matrix_times) if matrix_times else float('inf')\n",
       "        \n",
       "        # 3. Sin² Algorithm\n",
       "        sin2_times = []\n",
       "        sin2_result = None\n",
       "        for _ in range(iterations):\n",
       "            start = time.time()\n",
       "            sin2_result = sin2_algorithm(alpha, max_iterations=30)\n",
       "            end = time.time()\n",
       "            sin2_times.append(end - start)\n",
       "        sin2_avg_time = sum(sin2_times) / len(sin2_times)\n",
       "        \n",
       "        # Record results\n",
       "        results.append({\n",
       "            \"name\": name,\n",
       "            \"type\": alpha_type,\n",
       "            \"hapd_time\": hapd_avg_time,\n",
       "            \"hapd_result\": hapd_result,\n",
       "            \"matrix_time\": matrix_avg_time,\n",
       "            \"matrix_result\": matrix_result,\n",
       "            \"sin2_time\": sin2_avg_time,\n",
       "            \"sin2_result\": sin2_result\n",
       "        })\n",
       "        \n",
       "        print(f\"  HAPD:   {hapd_avg_time:.6f}s\")\n",
       "        print(f\"  Matrix: {matrix_avg_time:.6f}s\")\n",
       "        print(f\"  Sin²:   {sin2_avg_time:.6f}s\")\n",
       "    \n",
       "    # Visualization of performance comparison\n",
       "    if results:\n",
       "        # Extract data for plotting\n",
       "        names = [r[\"name\"] for r in results]\n",
       "        hapd_times = [r[\"hapd_time\"] for r in results]\n",
       "        matrix_times = [r[\"matrix_time\"] if r[\"matrix_time\"] != float('inf') else 0 for r in results]\n",
       "        sin2_times = [r[\"sin2_time\"] for r in results]\n",
       "        \n",
       "        # Create bar chart\n",
       "        x = np.arange(len(names))\n",
       "        width = 0.25\n",
       "        \n",
       "        fig, ax = plt.subplots(figsize=(12, 6))\n",
       "        rects1 = ax.bar(x - width, hapd_times, width, label='HAPD')\n",
       "        rects2 = ax.bar(x, matrix_times, width, label='Matrix')\n",
       "        rects3 = ax.bar(x + width, sin2_times, width, label='Sin²')\n",
       "        \n",
       "        ax.set_ylabel('Execution Time (s)')\n",
       "        ax.set_title('Performance Comparison of Cubic Irrational Detection Methods')\n",
       "        ax.set_xticks(x)\n",
       "        ax.set_xticklabels(names)\n",
       "        ax.legend()\n",
       "        \n",
       "        # Add value labels on bars\n",
       "        def autolabel(rects):\n",
       "            for rect in rects:\n",
       "                height = rect.get_height()\n",
       "                if height > 0:  # Only add label if there's a valid time\n",
       "                    ax.annotate(f'{height:.3f}',\n",
       "                                xy=(rect.get_x() + rect.get_width() / 2, height),\n",
       "                                xytext=(0, 3),  # 3 points vertical offset\n",
       "                                textcoords=\"offset points\",\n",
       "                                ha='center', va='bottom')\n",
       "        \n",
       "        autolabel(rects1)\n",
       "        autolabel(rects2)\n",
       "        autolabel(rects3)\n",
       "        \n",
       "        plt.tight_layout()\n",
       "        plt.show()\n",
       "        \n",
       "        # Create a summary table of results\n",
       "        print(\"\\nSummary of Detection Results\")\n",
       "        print(\"-\" * 70)\n",
       "        print(f\"{'Number':<15} {'Type':<20} {'HAPD':<12} {'Matrix':<12} {'Sin²':<12}\")\n",
       "        print(\"-\" * 70)\n",
       "        \n",
       "        for r in results:\n",
       "            hapd_class = r[\"hapd_result\"].get(\"classification\", \"N/A\") if r[\"hapd_result\"] else \"N/A\"\n",
       "            matrix_class = r[\"matrix_result\"].get(\"classification\", \"N/A\") if r[\"matrix_result\"] else \"N/A\"\n",
       "            sin2_status = r[\"sin2_result\"].get(\"status\", \"N/A\") if r[\"sin2_result\"] else \"N/A\"\n",
       "            \n",
       "            print(f\"{r['name']:<15} {r['type']:<20} {hapd_class:<12} {matrix_class:<12} {sin2_status:<12}\")\n",
       "        \n",
       "        print(\"-\" * 70)\n",
       "    \n",
       "    return results\n",
       "\n",
       "# Run performance comparison with 2 iterations for speed\n",
       "performance_results = performance_comparison(iterations=2)"
      ]
     }
    ],
    "metadata": {
     "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
     },
     "language_info": {
      "codemirror_mode": {
       "name": "ipython",
       "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.9.12"
     }
    },
    "nbformat": 4,
    "nbformat_minor": 4
   }